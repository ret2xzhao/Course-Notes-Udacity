1
00:00:00,440 --> 00:00:03,720
线性二次调节器（或 LQR）

2
00:00:04,080 --> 00:00:05,800
是基于模型的控制器

3
00:00:05,820 --> 00:00:08,900
它使用车辆的状态来使误差最小化

4
00:00:09,740 --> 00:00:12,640
Apollo 使用 LQR 进行横向控制

5
00:00:13,420 --> 00:00:15,800
横向控制包含四个组件：

6
00:00:16,500 --> 00:00:17,720
横向误差

7
00:00:18,220 --> 00:00:20,640
横向误差的变化率

8
00:00:21,100 --> 00:00:22,240
朝向误差

9
00:00:22,620 --> 00:00:24,580
和朝向的变化率

10
00:00:25,740 --> 00:00:28,420
变化率与导数相同

11
00:00:28,560 --> 00:00:31,460
我们用变量名上面的一个点来表示这个

12
00:00:32,460 --> 00:00:35,600
我们称这四个组件的集合为 x

13
00:00:36,180 --> 00:00:39,640
这个集合 x 捕获车辆的状态

14
00:00:40,600 --> 00:00:41,920
除了状态之外

15
00:00:42,160 --> 00:00:44,620
该车有三个控制输入：

16
00:00:44,960 --> 00:00:47,740
转向、加速和制动

17
00:00:48,580 --> 00:00:51,680
我们将这个控制输入集合称为 u

18
00:00:52,780 --> 00:00:55,080
LQR 处理线性控制

19
00:00:55,560 --> 00:00:58,580
这种类型的模型可以用等式来表示

20
00:00:58,860 --> 00:01:01,560
X(上方带点) = Ax + Bu

21
00:01:02,200 --> 00:01:04,460
X(上方带点)向量是导数

22
00:01:04,540 --> 00:01:06,840
或 x 向量的变化率

23
00:01:07,280 --> 00:01:12,860
所以 x 点的每个分量只是 x 相应分量的导数。

24
00:01:13,880 --> 00:01:17,420
等式 x 点 = Ax + Bu

25
00:01:17,860 --> 00:01:19,880
该等式捕捉 状态里的变化

26
00:01:20,040 --> 00:01:24,020
即 x 点  是如何受当前状态 x 

27
00:01:24,520 --> 00:01:26,540
和控制输入 u 的影响的

28
00:01:27,380 --> 00:01:29,020
这个等式是线性的

29
00:01:29,280 --> 00:01:31,960
因为当我们用 △x 来改变 x 时

30
00:01:32,320 --> 00:01:34,200
并用 △u 来改变 u 

31
00:01:34,580 --> 00:01:37,820
x 点的变化 也会让这个等式成立

32
00:01:39,180 --> 00:01:41,820
现在我们理解了 LQR 中的 L

33
00:01:42,660 --> 00:01:43,880
那么 Q 呢？

34
00:01:44,860 --> 00:01:47,800
这里的目标 就像控制的目标一样典型

35
00:01:48,080 --> 00:01:49,420
是为了让误差最小化

36
00:01:50,160 --> 00:01:53,880
但我们也希望尽可能少地使用控制输入

37
00:01:54,360 --> 00:01:55,560
由于使用这些会有成本

38
00:01:55,960 --> 00:01:58,000
例如 耗费气体或电力

39
00:01:59,140 --> 00:02:01,320
为了尽量减少这些因素

40
00:02:01,620 --> 00:02:03,980
我们可以保持误差的运行总和

41
00:02:04,040 --> 00:02:06,060
和控制输入的运行总和

42
00:02:06,880 --> 00:02:09,220
当汽车往右偏转得特别厉害之际

43
00:02:09,720 --> 00:02:11,480
添加到误差总和中

44
00:02:11,940 --> 00:02:14,840
当控制输入将汽车往左侧转时

45
00:02:15,120 --> 00:02:17,460
从控制输入总和中减去一点

46
00:02:18,200 --> 00:02:20,380
然而 这种方法会导致问题

47
00:02:20,700 --> 00:02:22,900
因为右侧的正误差

48
00:02:23,100 --> 00:02:25,840
只需将左侧的负误差消除即可

49
00:02:26,480 --> 00:02:28,800
对控制输入​​来说也是如此

50
00:02:29,300 --> 00:02:33,980
相反 我们可以让 x 乘以 u

51
00:02:34,520 --> 00:02:38,580
这样 负值也会产生正平方

52
00:02:39,380 --> 00:02:41,700
我们称这些为二次项

53
00:02:43,020 --> 00:02:46,100
我们为这些项分配权重 并将它们加在一起

54
00:02:47,020 --> 00:02:50,840
最优的 u 应该加倍减总和

55
00:02:51,720 --> 00:02:54,720
在数学中 我们将这个值称为成本函数

56
00:02:55,780 --> 00:02:59,900
我们经常写出加权二次项的总和

57
00:02:59,940 --> 00:03:02,080
以紧凑的矩阵形式呈现

58
00:03:02,640 --> 00:03:07,400
这里 Q 和 R 代表 x 和 u 的权重集合

59
00:03:08,820 --> 00:03:12,020
Xt 和 Ut 是转置矩阵

60
00:03:12,420 --> 00:03:15,320
这意味着它们几乎与 x 和 u 相同

61
00:03:15,580 --> 00:03:18,440
只是重新排列 以便矩阵乘法

62
00:03:19,460 --> 00:03:23,140
x 乘以 Xt u 乘以 Ut

63
00:03:23,500 --> 00:03:26,880
实质上是将每个矩阵乘以它自己

64
00:03:28,300 --> 00:03:31,920
最小化成本函数是一个复杂的过程

65
00:03:32,140 --> 00:03:36,880
但通常 我们可以依靠数值计算器为我们找到解决方案

66
00:03:37,700 --> 00:03:40,380
Apollo 就提供了一个这样的求解方案

67
00:03:41,060 --> 00:03:42,100
在 LQR 中

68
00:03:42,720 --> 00:03:47,280
控制方法被描述为 u = -Kx

69
00:03:47,400 --> 00:03:50,020
其中 K 代表一个复杂的 skeme

70
00:03:50,300 --> 00:03:52,940
代表如何从 x 计算出 u

71
00:03:53,700 --> 00:03:57,420
所以找到一个最优的 u 就是找到一个最优的 K

72
00:03:58,320 --> 00:04:01,160
许多工具都可以轻松地用来解决 K

73
00:04:01,240 --> 00:04:05,520
尤其当你提供了模拟车辆物理的 A、B

74
00:04:05,740 --> 00:04:09,220
以及 Q、R 它们是 x 和 u 的权重

