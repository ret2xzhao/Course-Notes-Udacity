1
00:00:00,000 --> 00:00:03,840
你好！欢迎学习开放式软件栈课程

2
00:00:03,840 --> 00:00:07,340
我们先来看看整体框架

3
00:00:07,340 --> 00:00:11,745
开放式软件层分为三个子层

4
00:00:11,745 --> 00:00:17,685
实时操作系统、运行时框架和应用程序模块层

5
00:00:17,685 --> 00:00:20,995
实时操作系统（或 RTOS）

6
00:00:20,995 --> 00:00:25,745
可确保在给定时间内完成特定任务

7
00:00:25,745 --> 00:00:28,320
“实时”是指无人驾驶车的操作系统

8
00:00:28,320 --> 00:00:32,790
能够及时进行计算

9
00:00:32,790 --> 00:00:37,220
分析并执行相应的操作

10
00:00:37,220 --> 00:00:40,945
以上是在汽车传感器收集到外界数据后的短时间内完成

11
00:00:40,945 --> 00:00:44,570
例如 假设无人驾驶车的传感器检测

12
00:00:44,570 --> 00:00:46,865
到车辆前方的移动障碍物

13
00:00:46,865 --> 00:00:49,880
短时间内 基于 RTOS 的 Apollo 软件模块

14
00:00:49,880 --> 00:00:53,395
必须分析障碍物是行人

15
00:00:53,395 --> 00:00:55,535
还是汽车 或是其他东西

16
00:00:55,535 --> 00:00:58,010
预测其未来的运动方向和速度

17
00:00:58,010 --> 00:01:01,665
并确定是减速还是停止

18
00:01:01,665 --> 00:01:04,595
然后 车辆必须执行该决定

19
00:01:04,595 --> 00:01:07,790
实时性能是确保

20
00:01:07,790 --> 00:01:11,485
系统稳定性和驾驶安全性的重要要求

21
00:01:11,485 --> 00:01:18,135
Apollo RTOS 是 Ubuntu Linux 操作系统与 Apollo 内核相互结合的成果

22
00:01:18,135 --> 00:01:22,445
Ubuntu 是业内顶级 Linux 发行版之一

23
00:01:22,445 --> 00:01:25,885
也是最流行的云操作系统

24
00:01:25,885 --> 00:01:30,435
然而 原始 Ubuntu 系统并非实时操作系统

25
00:01:30,435 --> 00:01:35,170
通过加入 Apollo 设计的内核 我们可以使其成为一个 RTOS

26
00:01:35,170 --> 00:01:39,440
运行时框架是 Apollo 的操作环境

27
00:01:39,440 --> 00:01:42,210
它是 ROS 的定制版

28
00:01:42,210 --> 00:01:44,190
即机器人操作系统

29
00:01:44,190 --> 00:01:47,195
尽管 ROS 代表机器人操作系统

30
00:01:47,195 --> 00:01:52,350
但它实际上是一个在 Apollo RTOS 上运行的软件框架

31
00:01:52,350 --> 00:01:57,360
ROS 在机器人行业有着悠久的历史

32
00:01:57,360 --> 00:02:02,585
目前有 3,000 多个基础库支持应用程序的快速开发

33
00:02:02,585 --> 00:02:07,850
ROS 根据功能将自治系统划分为多个模块

34
00:02:07,850 --> 00:02:10,440
每个模块负责接收、

35
00:02:10,440 --> 00:02:13,830
处理和发布自己的消息

36
00:02:13,830 --> 00:02:19,340
由于这些模块相互独立 只能通过运行时框架进行通信

37
00:02:19,340 --> 00:02:22,725
因此调整任何单一模块都很容易

38
00:02:22,725 --> 00:02:27,540
ROS 是应用最广泛的机器人框架

39
00:02:27,540 --> 00:02:31,320
因此它所包含的模块涉及许多最新的研究突破

40
00:02:31,320 --> 00:02:33,810
所有这些功能使 ROS 成为

41
00:02:33,810 --> 00:02:37,300
理想的 Apollo 开发与集成框架

42
00:02:37,300 --> 00:02:40,845
为使 ROS 适应无人驾驶车

43
00:02:40,845 --> 00:02:45,745
Apollo 团队改进了共享内存的功能和性能、

44
00:02:45,745 --> 00:02:49,345
去中心化和数据兼容性

45
00:02:49,345 --> 00:02:54,960
共享内存降低了需要访问不同模块时的数据复制需求

46
00:02:54,960 --> 00:02:57,535
对于一对多传输方案

47
00:02:57,535 --> 00:03:01,810
共享内存支持“一次写入 多次读取”模式

48
00:03:01,810 --> 00:03:08,115
例如 如果你只收到一次点云 你可以同时运行障碍物检测

49
00:03:08,115 --> 00:03:12,230
定位和 GUI 工具

50
00:03:12,230 --> 00:03:15,535
这可以加快通信速度

51
00:03:15,535 --> 00:03:19,820
去中心化解决了单点故障问题

52
00:03:19,820 --> 00:03:23,160
现成的 ROS 由许多节点组成

53
00:03:23,160 --> 00:03:26,350
每个节点都有对应的功能

54
00:03:26,350 --> 00:03:31,335
例如 一个节点可能负责收集摄像头图像

55
00:03:31,335 --> 00:03:36,040
另一个节点可能负责规划轨迹 而第三个节点

56
00:03:36,040 --> 00:03:40,830
可能负责将控制命令发送到 CAN 总线上的车辆

57
00:03:40,830 --> 00:03:44,840
但是所有这些节点都需要由单个 ROS 主节点来控制

58
00:03:44,840 --> 00:03:46,890
如果这个主节点发生故障

59
00:03:46,890 --> 00:03:48,920
整个系统都会失效

60
00:03:48,920 --> 00:03:51,030
为了避免这个问题

61
00:03:51,030 --> 00:03:54,990
Apollo 将所有节点放在一个公共域中

62
00:03:54,990 --> 00:04:00,200
域中的每个节点都有关于域中其他节点的信息

63
00:04:00,200 --> 00:04:02,705
通过这种去中心化方案

64
00:04:02,705 --> 00:04:06,580
公共域取代了原来的 ROS 主节点

65
00:04:06,580 --> 00:04:11,294
因此消除了单点故障风险

66
00:04:11,294 --> 00:04:16,110
对于无人驾驶车来说 由于项目本身的规模很大

67
00:04:16,110 --> 00:04:18,425
数据兼容性至关重要

68
00:04:18,425 --> 00:04:21,280
不同的 ROS 节点通过

69
00:04:21,280 --> 00:04:24,320
名为 ROS 消息的接口语言相互通信

70
00:04:24,320 --> 00:04:27,820
ROS 消息需要使用通用接口语言

71
00:04:27,820 --> 00:04:31,565
使每个节点都可以解读来自其他节点的消息数据

72
00:04:31,565 --> 00:04:34,450
如果消息文件的格式

73
00:04:34,450 --> 00:04:37,400
与节点所期望的格式稍有不同

74
00:04:37,400 --> 00:04:39,625
通信会失败

75
00:04:39,625 --> 00:04:42,990
这可能会导致严重的兼容性问题

76
00:04:42,990 --> 00:04:46,620
例如 当一个接口升级时

77
00:04:46,620 --> 00:04:50,470
数据不兼容通常会导致系统故障

78
00:04:50,470 --> 00:04:53,590
此外 必须一次又一次地转换

79
00:04:53,590 --> 00:04:58,015
之前所记录的测试数据 以适应新的消息格式

80
00:04:58,015 --> 00:04:59,745
为了解决这个问题

81
00:04:59,745 --> 00:05:02,530
Apollo 团队使用另一种名为 protobuf 的接口语言

82
00:05:02,530 --> 00:05:05,905
来替代原生 ROS 消息

83
00:05:05,905 --> 00:05:09,535
Protobuf 是一种结构化数据序列化方法

84
00:05:09,535 --> 00:05:12,834
这对开发用于通过电线彼此通信

85
00:05:12,834 --> 00:05:16,565
或用于存储数据的程序非常有用

86
00:05:16,565 --> 00:05:21,905
你可以将新字段添加到消息格式中 而不会破坏后向兼容性

87
00:05:21,905 --> 00:05:25,975
新的二进制文件可以在解析过程中接受旧的消息格式

88
00:05:25,975 --> 00:05:31,420
向 ROS 添加 protobuf 格式有助于 Apollo 的长期发展

89
00:05:31,420 --> 00:05:36,355
现在我们重点介绍本节课的核心内容 - 应用程序模块

90
00:05:36,355 --> 00:05:40,295
Apollo 的软件平台具有各种模块

91
00:05:40,295 --> 00:05:44,629
这些模块包括 MAP 引擎、定位、感知、

92
00:05:44,629 --> 00:05:51,190
规划、控制、端到端驾驶以及人机接口（或 HMI）

93
00:05:51,190 --> 00:05:54,290
每个模块都有自己的算法库

94
00:05:54,290 --> 00:05:57,775
模块之间的关系非常复杂

95
00:05:57,775 --> 00:06:00,380
我们将在整个课程中对这些模块

96
00:06:00,380 --> 00:06:03,080
及其关联方式进行研究

